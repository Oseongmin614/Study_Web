<!DOCTYPE html> <html> <head> <style> .ball { width: 50px; height: 50px; border-radius: 50%; position: absolute; } #redBall { background-color: red; } #blueBall { background-color: blue; } </style> </head> <body> <div id="redBall" class="ball"></div> <div id="blueBall" class="ball"></div> <script> // 요소 선택 const redBall = document.getElementById('redBall'); const blueBall = document.getElementById('blueBall'); // 공 설정 let redX = 100, redY = 100; let redSpeedX = 3, redSpeedY = 3; let blueX = 300, blueY = 100; let blueSpeedX = 0, blueSpeedY = 0; const MOVE_SPEED = 5; // 키 입력 상태 추적 객체 const keys = {}; // 키보드 이벤트 리스너 window.addEventListener('keydown', (e) => keys[e.key] = true); window.addEventListener('keyup', (e) => keys[e.key] = false); // 경계 충돌 처리 함수 function handleBoundaryCollision(obj) { const maxX = window.innerWidth - 50; const maxY = window.innerHeight - 50; let collision = false; // X축 경계 처리 if (obj.x < 0) { obj.x = 0; obj.speedX = Math.abs(obj.speedX); collision = true; } else if (obj.x > maxX) { obj.x = maxX; obj.speedX = -Math.abs(obj.speedX); collision = true; } // Y축 경계 처리 if (obj.y < 0) { obj.y = 0; obj.speedY = Math.abs(obj.speedY); collision = true; } else if (obj.y > maxY) { obj.y = maxY; obj.speedY = -Math.abs(obj.speedY); collision = true; } return collision; } // 애니메이션 루프 function update() { // 파란 공 속도 업데이트 blueSpeedX = keys.ArrowLeft ? -MOVE_SPEED : keys.ArrowRight ? MOVE_SPEED : 0; blueSpeedY = keys.ArrowUp ? -MOVE_SPEED : keys.ArrowDown ? MOVE_SPEED : 0; // 공 이동 redX += redSpeedX; redY += redSpeedY; blueX += blueSpeedX; blueY += blueSpeedY; // 경계 충돌 처리 handleBoundaryCollision({x: redX, y: redY, speedX: redSpeedX, speedY: redSpeedY}); handleBoundaryCollision({x: blueX, y: blueY, speedX: blueSpeedX, speedY: blueSpeedY}); // 공 충돌 검출 및 처리 const dx = redX - blueX; const dy = redY - blueY; const distance = Math.sqrt(dx*dx + dy*dy); if (distance < 50) { // 파란공에서 빨간공으로 향하는 벡터 계산 const normalX = dx / distance; const normalY = dy / distance; // 빨간공의 속도 크기 유지 const speed = Math.sqrt(redSpeedX*redSpeedX + redSpeedY*redSpeedY); // 파란공의 반대 방향으로 빨간공 속도 설정 redSpeedX = normalX * speed; redSpeedY = normalY * speed; } // 위치 업데이트 redBall.style.transform = `translate(${redX}px, ${redY}px)`; blueBall.style.transform = `translate(${blueX}px, ${blueY}px)`; requestAnimationFrame(update); } // 애니메이션 시작 update(); </script> </body> </html>